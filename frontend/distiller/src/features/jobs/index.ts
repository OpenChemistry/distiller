import {
  createAsyncThunk,
  createSlice,
  createEntityAdapter,
  PayloadAction,
  createSelector,
} from '@reduxjs/toolkit';
import { RootState } from '../../app/store';
import {
  getJobs as getJobsAPI,
  getJob as getJobAPI,
  patchJob as patchJobAPI,
  cancelJob as cancelJobAPI,
} from './api';
import { getScanJobs as getScanJobsAPI } from '../scans/api';
import {
  Job,
  IdType,
  JobsRequestResult,
  JobType,
  PendingJobStates,
  RunningJobStates,
} from '../../types';
import { DateTime } from 'luxon';

export const jobsAdapter = createEntityAdapter<Job>();

export interface JobsState
  extends ReturnType<(typeof jobsAdapter)['getInitialState']> {
  status: 'idle' | 'loading' | 'complete';
  totalCount: number;
  fetchedJobIds: IdType[];
  sessionJobId: IdType | null;
}

const initialState: JobsState = jobsAdapter.getInitialState({
  status: 'idle',
  totalCount: -1,
  fetchedJobIds: [] as IdType[],
  sessionJobId: null,
});

export const getJobs = createAsyncThunk<
  JobsRequestResult,
  {
    skip: number;
    limit: number;
    jobType?: JobType;
    start?: DateTime;
    end?: DateTime;
  }
>('jobs/fetch', async (payload, _thunkAPI) => {
  const { skip, limit, jobType, start, end } = payload;
  const result = await getJobsAPI(skip, limit, jobType, start, end);

  return result;
});

export const getJob = createAsyncThunk<Job, { id: IdType }>(
  'job/fetch',
  async (payload, _thunkAPI) => {
    const { id } = payload;
    const job = await getJobAPI(id);

    return job;
  }
);

export const getScanJobs = createAsyncThunk<
  Job[],
  {
    scanId: IdType;
  }
>('jobs/fetchByScanId', async (payload, _thunkAPI) => {
  const { scanId } = payload;
  const jobs = await getScanJobsAPI(scanId);

  return jobs;
});

export const patchJob = createAsyncThunk<
  Job,
  { id: IdType; updates: Partial<Job> }
>('jobs/patch', async (payload, _thunkAPI) => {
  const { id, updates } = payload;
  const job = await patchJobAPI(id, updates);

  return job;
});

export const cancelJob = createAsyncThunk<Job, { id: IdType }>(
  'jobs/delete',
  async (payload, _thunkAPI) => {
    const { id } = payload;
    const job = await cancelJobAPI(id);
    return job;
  }
);

export const jobsSlice = createSlice({
  name: 'jobs',
  initialState,
  reducers: {
    setJob(state, action: PayloadAction<Job>) {
      state.totalCount = state.totalCount + 1;
      jobsAdapter.setOne(state, action.payload);
    },
    updateJob(state, action: PayloadAction<Partial<Job>>) {
      const { id, ...changes } = action.payload;
      if (id !== undefined) {
        jobsAdapter.updateOne(state, { id, changes });
      }
    },
    addFetchedJobId(state, action: PayloadAction<IdType>) {
      if (!state.fetchedJobIds.includes(action.payload)) {
        state.fetchedJobIds.push(action.payload);
      }
    },
    setSessionJobId(state, action: PayloadAction<IdType>) {
      state.sessionJobId = action.payload;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(getJobs.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(getJobs.rejected, (state) => {
        state.status = 'idle';
      })
      .addCase(getJobs.fulfilled, (state, action) => {
        const { totalCount, jobs } = action.payload;
        state.status = 'complete';
        state.totalCount = totalCount;
        jobsAdapter.upsertMany(state, jobs);
      })
      .addCase(getJob.fulfilled, (state, action) => {
        const job = action.payload;
        jobsAdapter.upsertOne(state, job);
      })
      .addCase(getScanJobs.fulfilled, (state, action) => {
        const jobs = action.payload;
        jobsAdapter.upsertMany(state, jobs);
      })
      .addCase(patchJob.fulfilled, (state, action) => {
        const update = {
          id: action.payload.id,
          changes: action.payload,
        };
        jobsAdapter.updateOne(state, update);
      });
  },
});

export const jobsSelector = jobsAdapter.getSelectors<RootState>(
  (state) => state.jobs
);

const jobState = (rootState: RootState) => rootState.jobs;

const { selectById } = jobsAdapter.getSelectors();
export const jobSelector = (id: IdType) => {
  return createSelector(jobState, (state) => selectById(state, id));
};

const filterJob =
  (scanId: IdType, jobType: JobType | null) =>
  (job: Job | undefined): job is Job =>
    job !== undefined &&
    job.scanIds &&
    job.scanIds.includes(scanId) &&
    job.job_type !== jobType;

export const jobsByScanIdSelector = (scanId: IdType) => {
  return createSelector(jobState, (state) => {
    return Object.values(state.entities).filter(filterJob(scanId, null));
  });
};

export const nonStreamingJobsSelector = (scanId: IdType) => {
  return createSelector(jobState, (state) => {
    return Object.values(state.entities).filter(
      filterJob(scanId, JobType.Streaming)
    );
  });
};

export const jobsExistInStore = (state: RootState, jobIds: IdType[]) => {
  const jobsInState = jobIds.map((id) =>
    jobsAdapter.getSelectors().selectById(state.jobs, id)
  );
  return jobsInState.every((job) => job !== undefined);
};

export const selectJobsByPageAndDate = (
  page: number,
  itemsPerPage: number,
  startDateFilter: DateTime | null,
  endDateFilter: DateTime | null,
  jobType: JobType | null
) => {
  return createSelector(
    [jobState, (state: RootState) => state],
    (jobsState, state) => {
      let jobs = Object.values(jobsState.entities) as Job[];

      if (startDateFilter) {
        jobs = jobs.filter(
          (job) => job.submit && DateTime.fromISO(job.submit) >= startDateFilter
        );
      }

      if (endDateFilter) {
        jobs = jobs.filter(
          (job) => job.submit && DateTime.fromISO(job.submit) <= endDateFilter
        );
      }

      if (jobType) {
        jobs = jobs.filter((job) => job.job_type === jobType);
      }

      jobs.sort((a, b) => b.id - a.id);

      const start = page * itemsPerPage;
      const end = start + itemsPerPage;
      jobs = jobs.slice(start, end);

      return jobs;
    }
  );
};

export const anyStreamingJobsSelector = createSelector(jobState, (state) => {
  return Object.values(state.entities).some((job) => {
    if (job && job.state) {
      if (job.job_type === JobType.Streaming) {
        // Check if job is in pending and has slurm id, or is in running state
        if (
          (PendingJobStates.has(job.state) && job.slurm_id) ||
          RunningJobStates.has(job.state)
        ) {
          return true;
        }
      }
    }
    return false;
  });
});

export const fetchedJobIdsSelector = (state: RootState) =>
  state.jobs.fetchedJobIds;

export const totalCount = (state: RootState) => state.jobs.totalCount;

export const { setJob, updateJob, addFetchedJobId, setSessionJobId } =
  jobsSlice.actions;

export default jobsSlice.reducer;
