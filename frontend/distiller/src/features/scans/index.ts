import {
  PayloadAction,
  createAsyncThunk,
  createEntityAdapter,
  createSelector,
  createSlice,
} from '@reduxjs/toolkit';
import { DateTime } from 'luxon';
import { RootState } from '../../app/store';
import { IdType, Scan, ScansRequestResult } from '../../types';
import { getJobScans as getJobScansAPI } from '../jobs/api';
import {
  getScan as getScanAPI,
  getScans as getScansAPI,
  patchScan as patchScanAPI,
  removeScan as removeScanAPI,
  removeScanFiles as removeScanFilesAPI,
} from './api';

export const scansAdapter = createEntityAdapter<Scan>();

export interface ScansState
  extends ReturnType<(typeof scansAdapter)['getInitialState']> {
  status: 'idle' | 'loading' | 'complete';
  totalCount: number;
  scanIdsInCurrentPage: number[];
}

const initialState: ScansState = scansAdapter.getInitialState({
  status: 'idle',
  totalCount: -1,
  scanIdsInCurrentPage: [],
});

export const getScans = createAsyncThunk<
  ScansRequestResult,
  {
    skip: number;
    limit: number;
    start?: DateTime;
    end?: DateTime;
    microscopeId: IdType;
  }
>('scans/fetch', async (_payload, _thunkAPI) => {
  const { skip, limit, start, end, microscopeId } = _payload;
  const result = await getScansAPI(microscopeId, skip, limit, start, end);

  return result;
});

export const getScan = createAsyncThunk<Scan, { id: IdType }>(
  'scan/fetch',
  async (payload, _thunkAPI) => {
    const { id } = payload;
    const scan = await getScanAPI(id);

    return scan;
  },
);

export const getJobScans = createAsyncThunk<
  { scans: Scan[] | null },
  {
    jobId: IdType;
  },
  { state: RootState }
>('scans/fetchByJobId', async (payload, _thunkAPI) => {
  const { jobId } = payload;
  const state = _thunkAPI.getState();

  const jobExists = state.jobs.ids.includes(jobId);

  if (!jobExists) {
    // If the scan does not exist in state, throw an error
    throw new Error(`Job with ID ${jobId} does not exist in state.`);
  }

  const scan_ids = state.jobs.entities[jobId]?.scan_ids || [];

  const scansInState = scan_ids.map((id) => selectById(state.scans, id));

  const allScansInStore = scansInState.every((scan) => scan !== undefined);

  if (allScansInStore) {
    // If all jobs are already in the store, return null to avoid unnecessary reducer
    return { scans: null };
  } else {
    // If any job is not in the store, make the API call
    const scans = await getJobScansAPI(jobId);
    return { scans };
  }
});

export const patchScan = createAsyncThunk<
  Scan,
  { id: IdType; updates: Partial<Scan> }
>('scans/patch', async (payload, _thunkAPI) => {
  const { id, updates } = payload;
  const scan = await patchScanAPI(id, updates);

  return scan;
});

export const removeScanFiles = createAsyncThunk<
  void,
  { id: IdType; host: string }
>('scans/remove-files', async (payload, _thunkAPI) => {
  const { id, host } = payload;
  await removeScanFilesAPI(id, host);
});

export const removeScan = createAsyncThunk<
  IdType,
  { id: IdType; removeScanFiles: boolean }
>('scans/remove', async (payload, _thunkAPI) => {
  const { id, removeScanFiles } = payload;
  await removeScanAPI(id, removeScanFiles);

  return id;
});

export const scansSlice = createSlice({
  name: 'scans',
  initialState,
  reducers: {
    setScan(state, action: PayloadAction<Scan>) {
      state.totalCount = state.totalCount + 1;
      scansAdapter.setOne(state, action.payload);
    },
    updateScan(state, action: PayloadAction<Partial<Scan>>) {
      // const currentScan = scansSelector.selectById
      const { id, ...changes } = action.payload;
      if (id !== undefined) {
        scansAdapter.updateOne(state, { id, changes });
      }
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(getScans.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(getScans.rejected, (state) => {
        state.status = 'idle';
      })
      .addCase(getScans.fulfilled, (state, action) => {
        const { totalCount, scans } = action.payload;

        state.status = 'complete';
        state.totalCount = totalCount;
        state.scanIdsInCurrentPage = scans.map((scan) => scan.id);
        scansAdapter.upsertMany(state, scans);
      })
      .addCase(getScan.fulfilled, (state, action) => {
        scansAdapter.upsertOne(state, action.payload);
      })
      .addCase(getJobScans.fulfilled, (state, action) => {
        const scans = action.payload.scans;
        if (scans) {
          scansAdapter.upsertMany(state, scans);
        }
      })
      .addCase(patchScan.fulfilled, (state, action) => {
        const update = {
          id: action.payload.id,
          changes: action.payload,
        };
        scansAdapter.updateOne(state, update);
      })
      .addCase(removeScan.fulfilled, (state, action) => {
        scansAdapter.removeOne(state, action.payload);
      });
  },
});

export const scansSelector = scansAdapter.getSelectors<RootState>(
  (state) => state.scans,
);

const scansState = (rootState: RootState) => rootState.scans;

const { selectById, selectAll } = scansAdapter.getSelectors();

export const scanSelector = (id: IdType) => {
  return createSelector(scansState, (state) => selectById(state, id));
};

export const allScansSelector = createSelector(scansState, (scansState) =>
  selectAll(scansState),
);

export const scansInCurrentPageSelector = createSelector(
  scansState,
  (scansState) => {
    return scansState.scanIdsInCurrentPage
      .map((scanId) => selectById(scansState, scanId))
      .filter((scan) => scan !== undefined);
  },
);

const filterScanByJobId = (jobId: IdType) => (scan: Scan) =>
  scan.job_ids && scan.job_ids.includes(jobId);

const filterScanByDate =
  (startDateFilter: DateTime | null, endDateFilter: DateTime | null) =>
  (scan: Scan) => {
    if (
      startDateFilter &&
      scan.created &&
      DateTime.fromISO(scan.created) < startDateFilter
    ) {
      return false;
    }
    if (
      endDateFilter &&
      scan.created &&
      DateTime.fromISO(scan.created) > endDateFilter
    ) {
      return false;
    }
    return true;
  };

export const scansByJobIdSelector = (jobId: IdType) => {
  return createSelector(allScansSelector, (scans) => {
    return scans.filter(filterScanByJobId(jobId));
  });
};

export const scansByDateSelector = (
  startDateFilter: DateTime | null,
  endDateFilter: DateTime | null,
) => {
  return createSelector([allScansSelector], (scans) => {
    scans = scans.filter(filterScanByDate(startDateFilter, endDateFilter));
    return scans;
  });
};

export const totalCount = (state: RootState) => state.scans.totalCount;

export const { setScan, updateScan } = scansSlice.actions;

export default scansSlice.reducer;
