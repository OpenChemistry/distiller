import {
  PayloadAction,
  createAsyncThunk,
  createEntityAdapter,
  createSelector,
  createSlice,
} from '@reduxjs/toolkit';
import { DateTime } from 'luxon';
import { RootState } from '../../app/store';
import { IdType, Job, JobType, JobsRequestResult } from '../../types';
import { scanSelector } from '../scans';
import { getScanJobs as getScanJobsAPI } from '../scans/api';
import {
  cancelJob as cancelJobAPI,
  getJob as getJobAPI,
  getJobs as getJobsAPI,
  patchJob as patchJobAPI,
} from './api';

export const jobsAdapter = createEntityAdapter<Job>();

export interface JobsState
  extends ReturnType<(typeof jobsAdapter)['getInitialState']> {
  status: 'idle' | 'loading' | 'complete';
  totalCount: number;
}

const initialState: JobsState = jobsAdapter.getInitialState({
  status: 'idle',
  totalCount: -1,
});

export const getJobs = createAsyncThunk<
  JobsRequestResult,
  {
    skip: number;
    limit: number;
    jobType?: JobType;
    start?: DateTime;
    end?: DateTime;
  }
>('jobs/fetch', async (payload, _thunkAPI) => {
  const { skip, limit, jobType, start, end } = payload;
  const result = await getJobsAPI(skip, limit, jobType, start, end);

  return result;
});

export const getJob = createAsyncThunk<Job, { id: IdType }>(
  'job/fetch',
  async (payload, _thunkAPI) => {
    const { id } = payload;
    const job = await getJobAPI(id);

    return job;
  },
);

export const getScanJobs = createAsyncThunk<
  { jobs: Job[] | null },
  {
    scanId: IdType;
  },
  { state: RootState }
>('jobs/fetchByScanId', async (payload, thunkAPI) => {
  const { scanId } = payload;
  const state = thunkAPI.getState();

  // Optimization, only fetch jobs if we haven't already
  let doFetch = true;

  // First, check if the requested scan exists in the store
  // If the scan is not in the store, the getScan request hasn't resolved yet.
  // So just fetch the jobs regardless since it's likely we haven't fetched the
  // relevant jobs anyway.
  const scan = scanSelector(scanId)(state);

  if (scan) {
    const jobIds = scan.job_ids;
    const jobsInState = jobIds.map((id) => jobSelector(id)(state));
    doFetch = jobsInState.some((job) => job === undefined);
  }

  if (doFetch) {
    // Make the API call
    const jobs = await getScanJobsAPI(scanId);
    return { jobs };
  } else {
    return { jobs: null };
  }
});

export const patchJob = createAsyncThunk<
  Job,
  { id: IdType; updates: Partial<Job> }
>('jobs/patch', async (payload, _thunkAPI) => {
  const { id, updates } = payload;
  const job = await patchJobAPI(id, updates);

  return job;
});

export const cancelJob = createAsyncThunk<Job, { id: IdType }>(
  'jobs/delete',
  async (payload, _thunkAPI) => {
    const { id } = payload;
    const job = await cancelJobAPI(id);
    return job;
  },
);

export const jobsSlice = createSlice({
  name: 'jobs',
  initialState,
  reducers: {
    setJob(state, action: PayloadAction<Job>) {
      state.totalCount = state.totalCount + 1;
      jobsAdapter.setOne(state, action.payload);
    },
    updateJob(state, action: PayloadAction<Partial<Job>>) {
      const { id, ...changes } = action.payload;
      if (id !== undefined) {
        jobsAdapter.updateOne(state, { id, changes });
      }
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(getJobs.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(getJobs.rejected, (state) => {
        state.status = 'idle';
      })
      .addCase(getJobs.fulfilled, (state, action) => {
        const { totalCount, jobs } = action.payload;
        state.status = 'complete';
        state.totalCount = totalCount;
        jobsAdapter.upsertMany(state, jobs);
      })
      .addCase(getJob.fulfilled, (state, action) => {
        const job = action.payload;
        jobsAdapter.upsertOne(state, job);
      })
      .addCase(getScanJobs.fulfilled, (state, action) => {
        const jobs = action.payload.jobs;
        if (jobs !== null) {
          jobsAdapter.upsertMany(state, jobs);
        }
      })
      .addCase(patchJob.fulfilled, (state, action) => {
        const update = {
          id: action.payload.id,
          changes: action.payload,
        };
        jobsAdapter.updateOne(state, update);
      });
  },
});

export const jobsSelector = jobsAdapter.getSelectors<RootState>(
  (state) => state.jobs,
);

const jobsState = (rootState: RootState) => rootState.jobs;

const { selectById, selectAll } = jobsAdapter.getSelectors();

export const jobSelector = (id: IdType) => {
  return createSelector(jobsState, (state) => selectById(state, id));
};

export const allJobsSelector = createSelector(jobsState, (jobsState) =>
  selectAll(jobsState),
);

const filterJobByScanId = (scanId: IdType) => (job: Job) =>
  job.scan_ids && job.scan_ids.includes(scanId);

const filterJobByTypes = (jobTypes: JobType[] | null) => (job: Job) => {
  if (jobTypes) {
    return jobTypes.includes(job.job_type);
  }
};

const filterJobByDate =
  (startDateFilter: DateTime | null, endDateFilter: DateTime | null) =>
  (job: Job) => {
    if (
      startDateFilter &&
      job.submit &&
      DateTime.fromISO(job.submit) < startDateFilter
    ) {
      return false;
    }
    if (
      endDateFilter &&
      job.submit &&
      DateTime.fromISO(job.submit) > endDateFilter
    ) {
      return false;
    }
    return true;
  };

export const jobsByScanIdSelector = (scanId: IdType) => {
  return createSelector(allJobsSelector, (jobs) => {
    return jobs.filter(filterJobByScanId(scanId));
  });
};

export const jobsByScanIdAndTypes = (scanId: IdType, jobTypes: JobType[]) => {
  return createSelector(jobsByScanIdSelector(scanId), (jobs) => {
    return jobs.filter(filterJobByTypes(jobTypes));
  });
};

export const selectJobsByDateAndTypes = (
  startDateFilter: DateTime | null,
  endDateFilter: DateTime | null,
  jobTypes: JobType[] | null,
) => {
  return createSelector([allJobsSelector], (jobs) => {
    jobs = jobs.filter(filterJobByDate(startDateFilter, endDateFilter));
    jobs = jobs.filter(filterJobByTypes(jobTypes));
    return jobs;
  });
};

export const totalCount = (state: RootState) => state.jobs.totalCount;

export const { setJob, updateJob } = jobsSlice.actions;

export default jobsSlice.reducer;
