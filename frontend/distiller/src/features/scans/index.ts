import {
  createAsyncThunk,
  createSlice,
  createEntityAdapter,
  PayloadAction,
  createSelector,
} from '@reduxjs/toolkit';
import { RootState } from '../../app/store';
import {
  getScans as getScansAPI,
  getScan as getScanAPI,
  patchScan as patchScanAPI,
  removeScanFiles as removeScanFilesAPI,
  removeScan as removeScanAPI,
} from './api';
import { getJobScans as getJobScansAPI } from '../jobs/api';
import { Scan, IdType, ScansRequestResult } from '../../types';
import { DateTime } from 'luxon';

export const scansAdapter = createEntityAdapter<Scan>();

export interface ScansState
  extends ReturnType<(typeof scansAdapter)['getInitialState']> {
  status: 'idle' | 'loading' | 'complete';
  totalCount: number;
}

const initialState: ScansState = scansAdapter.getInitialState({
  status: 'idle',
  totalCount: -1,
});

export const getScans = createAsyncThunk<
  ScansRequestResult,
  {
    skip: number;
    limit: number;
    start?: DateTime;
    end?: DateTime;
    microscopeId: IdType;
  }
>('scans/fetch', async (_payload, _thunkAPI) => {
  const { skip, limit, start, end, microscopeId } = _payload;
  const result = await getScansAPI(microscopeId, skip, limit, start, end);

  return result;
});

export const getScan = createAsyncThunk<Scan, { id: IdType }>(
  'scan/fetch',
  async (payload, _thunkAPI) => {
    const { id } = payload;
    const scan = await getScanAPI(id);

    return scan;
  }
);

export const getJobScans = createAsyncThunk<
  { scans: Scan[] | null },
  {
    jobId: IdType;
  },
  { state: RootState }
>('scans/fetchByJobId', async (payload, _thunkAPI) => {
  const { jobId } = payload;
  const state = _thunkAPI.getState();

  const jobExists = state.jobs.ids.includes(jobId);

  if (!jobExists) {
    // If the scan does not exist in state, throw an error
    throw new Error(`Job with ID ${jobId} does not exist in state.`);
  }

  const scanIds = state.jobs.entities[jobId]?.scanIds || [];

  const scansInState = scanIds.map((id) => selectById(state.scans, id));

  const allScansInStore = scansInState.every((scan) => scan !== undefined);

  if (allScansInStore) {
    // If all jobs are already in the store, return null to avoid unnecessary reducer
    return { scans: null };
  } else {
    // If any job is not in the store, make the API call
    const scans = await getJobScansAPI(jobId);
    return { scans };
  }
});

export const patchScan = createAsyncThunk<
  Scan,
  { id: IdType; updates: Partial<Scan> }
>('scans/patch', async (payload, _thunkAPI) => {
  const { id, updates } = payload;
  const scan = await patchScanAPI(id, updates);

  return scan;
});

export const removeScanFiles = createAsyncThunk<
  void,
  { id: IdType; host: string }
>('scans/remove-files', async (payload, _thunkAPI) => {
  const { id, host } = payload;
  await removeScanFilesAPI(id, host);
});

export const removeScan = createAsyncThunk<
  IdType,
  { id: IdType; removeScanFiles: boolean }
>('scans/remove', async (payload, _thunkAPI) => {
  const { id, removeScanFiles } = payload;
  await removeScanAPI(id, removeScanFiles);

  return id;
});

export const scansSlice = createSlice({
  name: 'scans',
  initialState,
  reducers: {
    setScan(state, action: PayloadAction<Scan>) {
      state.totalCount = state.totalCount + 1;
      scansAdapter.setOne(state, action.payload);
    },
    updateScan(state, action: PayloadAction<Partial<Scan>>) {
      // const currentScan = scansSelector.selectById
      const { id, ...changes } = action.payload;
      if (id !== undefined) {
        scansAdapter.updateOne(state, { id, changes });
      }
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(getScans.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(getScans.rejected, (state) => {
        state.status = 'idle';
      })
      .addCase(getScans.fulfilled, (state, action) => {
        const { totalCount, scans } = action.payload;

        state.status = 'complete';
        state.totalCount = totalCount;
        scansAdapter.upsertMany(state, scans);
      })
      .addCase(getScan.fulfilled, (state, action) => {
        scansAdapter.upsertOne(state, action.payload);
      })
      .addCase(getJobScans.fulfilled, (state, action) => {
        const scans = action.payload.scans;
        if (scans) {
          scansAdapter.upsertMany(state, scans);
        }
      })
      .addCase(patchScan.fulfilled, (state, action) => {
        const update = {
          id: action.payload.id,
          changes: action.payload,
        };
        scansAdapter.updateOne(state, update);
      })
      .addCase(removeScan.fulfilled, (state, action) => {
        scansAdapter.removeOne(state, action.payload);
      });
  },
});

export const scansSelector = scansAdapter.getSelectors<RootState>(
  (state) => state.scans
);

const scansState = (rootState: RootState) => rootState.scans;

const { selectById, selectAll } = scansAdapter.getSelectors();

export const scanSelector = (id: IdType) => {
  return createSelector(scansState, (state) => selectById(state, id));
};

export const totalCount = (state: RootState) => state.scans.totalCount;

export const { setScan, updateScan } = scansSlice.actions;

export const scansByJobIdSelector = (jobId: IdType) => {
  return createSelector(scanState, (state) => {
    return Object.values(state.entities).filter(
      (scan): scan is Scan =>
        scan !== undefined && scan.jobIds && scan.jobIds.includes(jobId)
    );
  });
};

export const selectScansByPageAndDate = (
  page: number,
  itemsPerPage: number,
  startDateFilter: DateTime | null,
  endDateFilter: DateTime | null
) => {
  return createSelector(
    [scanState, (state: RootState) => state],
    (scansState, state) => {
      let scans = Object.values(scansState.entities) as Scan[];

      // If start date is defined, filter scans created after start date
      if (startDateFilter) {
        scans = scans.filter(
          (scan) =>
            scan.created && DateTime.fromISO(scan.created) >= startDateFilter
        );
      }

      // If end date is defined, filter scans created before end date
      if (endDateFilter) {
        scans = scans.filter(
          (scan) =>
            scan.created && DateTime.fromISO(scan.created) <= endDateFilter
        );
      }

      scans = scans.sort((a, b) => b.created.localeCompare(a.created));

      const start = page * itemsPerPage;
      const end = start + itemsPerPage;
      scans = scans.slice(start, end);

      return scans;
    }
  );
};

export default scansSlice.reducer;
